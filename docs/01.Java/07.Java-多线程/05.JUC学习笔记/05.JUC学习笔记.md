---
title: JUC学习笔记（三）
permalink: /java/se/thread/study-note/5
date: 2021-05-17 18:01:25
---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [十 线程池](#%E5%8D%81-%E7%BA%BF%E7%A8%8B%E6%B1%A0)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 十一 线程池

::: tip 池化技术

:::

程序的运行，其本质上，是对系统资源(CPU、内存、磁盘、网络等等)的使用。如何高效的使用这些资源 是我们编程优化演进的一个方向。今天说的线程池就是一种对CPU利用的优化手段。

通过学习线程池原理，明白所有池化技术的基本设计思路。遇到其他相似问题可以解决。

前面提到一个名词——**池化技术**，那么到底什么是池化技术呢 ?

池化技术简单点来说，就是提前保存大量的资源，以备不时之需。在机器资源有限的情况下，使用池化 技术可以大大的提高资源的利用率，提升性能等。

在编程领域，比较典型的池化技术有：**线程池、连接池、内存池、对象池等。**

我们通过创建一个线程对象，并且实现Runnable接口就可以实现一个简单的线程。可以利用上多核 CPU。当一个任务结束，当前线程就接收。

但很多时候，我们不止会执行一个任务。如果每次都是如此的创建线程->执行任务->销毁线程，会造成很大的性能开销。

那能否一个线程创建后，执行完一个任务后，又去执行另一个任务，而不是销毁。这就是线程池。

这也就是池化技术的思想，通过预先创建好多个线程，放在池中，这样可以在需要使用线程的时候直接获取，避免多次重复创建、销毁带来的开销。

::: tip 为什么使用线程池

:::

10 年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球 ，CPU 需要来回切换。

现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。

**线程池的优势：**

线程池做的工作主要是：控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这 些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。

**它的主要特点为：线程复用，控制最大并发数，管理线程。**

第一：降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。

第三：提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配，调优和监控。



### ExecutorService



::: tip 线程池的三大方法

:::

Java中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor ，Executors， ExecutorService，ThreadPoolExecutor 这几个类。

![JUC-00000021](05.JUC学习笔记.assets/JUC-00000021.png)

三大方法说明：

- `Executors.newFixedThreadPool(int)`

  执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程。

  

- `Executors.newSingleThreadExecutor()`

  只有一个线程

- `Executors.newCachedThreadPool()`

  执行很多短期异步任务，线程池根据需要创建新线程，但在先构建的线程可用时将重用他们。 可扩容，遇强则强



```java
public class MyThreadPoolDemo {
    public static void main(String[] args) {
        /** 1、池子大小 5 
         * 模拟有10个顾客过来银行办理业务，池子中只有5个工作人员受理业务
         */
//        ExecutorService threadPool = Executors.newFixedThreadPool(5);


        /** 2、有且只有一个固定的线程
         * 模拟有10个顾客过来银行办理业务，池子中只有1个工作人员受理业务
         */
//        ExecutorService threadPool =  Executors.newSingleThreadExecutor();
        
        /**  3、一池N线程，可扩容伸缩
         * 模拟有10个顾客过来银行办理业务，池子中N个工作人员受理业务
         */
        ExecutorService threadPool = Executors.newCachedThreadPool();
        
        try {
            for (int i = 1; i <= 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + " 办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown(); // 用完记得关闭
        }
    }

}
```



### ThreadPoolExecutor



::: tip ThreadPoolExecutor 七大参数

:::

查看三大方法的调用源码，发现本质都是调用了 new ThreadPoolExecutor ( 7 大参数 )

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {

}
```

1、`corePollSize`

核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中。

2、`maximumPoolSize`

最大线程数。表明线程中最多能够创建的线程数量，此值必须大于等于1。

3、`keepAliveTime`

空闲的线程保留的时间，达到这个时间后，自动释放

4、`TimeUnit`

空闲线程的保留时间单位。

```java
TimeUnit.DAYS; //天
TimeUnit.HOURS; //小时
TimeUnit.MINUTES; //分钟
TimeUnit.SECONDS; //秒
TimeUnit.MILLISECONDS; //毫秒
TimeUnit.MICROSECONDS; //微妙
TimeUnit.NANOSECONDS; //纳秒
```

5、`BlockingQueue<Runnable> workQueue`

阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、 LinkedBlockingQueue、SynchronousQueue可选。

6、`ThreadFactory`

线程工厂，用来创建线程，一般默认即可

7、`RejectedExecutionHandler`

队列已满，而且任务量大于最大线程的异常处理策略。有以下取值

```java
ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
```

::: tip ThreadPoolExecutor层工作原理

:::

![JUC-00000022](05.JUC学习笔记.assets/JUC-00000022.png)

举例：8个人进银行办理业务

1、1~2人被受理（核心大小core） 

2、3~5人进入队列（Queue） 

3、6~8人到最大线程池（扩容大小max） 

4、再有人进来就要被拒绝策略接受了

![JUC-00000023](05.JUC学习笔记.assets/JUC-00000023.png)

1、在创建了线程池后，开始等待请求。

2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：

- 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务
- 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列
- 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非 核心线程立刻运行这个任务
- 如果队列满了且正在运行的线程数量大于或等于1Size，那么线程池会启动饱和拒绝策略来执行。

3、当一个线程完成任务时，它会从队列中取下一个任务来执行

4、 当一个线程无事可做超过一定的时间(keepAliveTime)时，线程会判断：

如果当前运行的线程数大于corePollSize，那么这个线程就被停掉。

所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。



::: tip 线程池用哪个？生产中如何设置合理参数

:::

Executors 中 JDK 已经给你提供了，为什么不用？

![JUC-00000024](05.JUC学习笔记.assets/JUC-00000024.png)

::: note 代码测试：

:::

线程池的拒绝策略：

```java
RejectedExecutionHandler rejected = null;

//默认，队列满了丢任务，抛出异常
rejected = new ThreadPoolExecutor.AbortPolicy();
//队列满了丢任务，不抛出异常【如果允许任务丢失这是最好的】
rejected = new ThreadPoolExecutor.DiscardPolicy();
//将最早进入队列的任务删，之后再尝试加入队列
rejected = new ThreadPoolExecutor.DiscardOldestPolicy();
////如果添加到线程池失败，那么主线程会自己去执行该任务，回退
rejected = new ThreadPoolExecutor.CallerRunsPolicy();
```





```java
public class MyThreadPoolDemo2 {

    public static void main(String[] args) {


        // 自定义 ThreadPoolExecutor
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                Runtime.getRuntime().availableProcessors(),
                2L,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.DiscardPolicy());
        try {
            // 模拟有6,7,8,9,10个顾客过来银行办理业务，观察结果情况
            // 最大容量为：maximumPoolSize + workQueue = 最大容量数
            for (int i = 1; i <= 19; i++) {
                int num = i;
                threadPool.execute(() -> {
                    System.out.println(num + " " + Thread.currentThread().getName() + " ok");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown(); // 用完记得关闭
        }

    }
}
```

**线程是否越多越好？**

一个计算为主的程序（专业一点称为**CPU密集型程序**）。多线程跑的时候，可以充分利用起所有的 cpu 核心，比如说4个核心的cpu，开4个线程的时候，可以同时跑4个线程的运算任务，此时是最大效率。但是如果线程远远超出cpu核心数量反而会使得任务效率下降，因为频繁的切换线程也是要消耗时间的。因此对于cpu密集型的任务来说，线程数等于cpu数是最好的了。

如果是一个磁盘或网络为主的程序（**IO密集型**）。一个线程处在IO等待的时候，另一个线程还可以在 CPU里面跑，有时候CPU闲着没事干，所有的线程都在等着IO，这时候他们就是同时的了，而单线程的话此时还是在一个一个等待的。我们都知道IO的速度比起CPU来是慢到令人发指的。所以开多线程，比 方说多线程网络传输，多线程往不同的目录写文件，等等。此时线程数等于IO任务数是最佳的。



## 十二 四大函数式接口

在java.util.function包下，Java 内置核心四大函数式接口，可以使用lambda表达式

![JUC-00000025](05.JUC学习笔记.assets/JUC-00000025.png)

::: note 函数型接口，有一个输入，有一个输出

:::

Function

```java
package com.oddfar.function;

import java.util.function.Function;

/**
 * @author zhiyuan
 */
public class Demo01 {
    public static void main(String[] args) {
//        Function<String,Integer> function = new Function<String,Integer>() {
//            @Override
//            public Integer apply(String s) {
//                return s.length();
//            }
//        };

        Function<String,Integer> function = (s)->{return  s.length();};

        System.out.println(function.apply("abc"));
    }
}
```



::: note 断定型接口，有一个输入参数，返回只有布尔值。

:::

Predicate

```java
public class Demo02 {
    public static void main(String[] args) {
//        Predicate<String> predicate = new Predicate<String>() {
//            @Override
//            public boolean test(String s) {
//                return s.isEmpty();
//            }
//        };
        Predicate<String> predicate = (s)->{return s.isEmpty();};

        System.out.println(predicate.test("abc"));

    }
}
```



::: note 消费型接口，有一个输入参数，没有返回值

:::

Consumer

```java
public class Demo03 {
    public static void main(String[] args) {

//        Consumer<String> consumer = new Consumer<String>() {
//            @Override
//            public void accept(String s) {
//                System.out.println(s);
//            }
//        };
        Consumer<String> consumer = s -> { System.out.println(s); };
        consumer.accept("abc");
    }

}
```

::: note 供给型接口，没有输入参数，只有返回参数

:::

Supplier

```java
public class Demo04 {
    public static void main(String[] args) {
//        Supplier<String> supplier = new Supplier<String>() {
//            @Override
//            public String get() {
//                return null;
//            }
//        };
        Supplier<String> supplier = () -> { return "abc";};
        System.out.println(supplier.get());
    }

}
```

## 13、Stream流式计算

::: tip 流（Stream）到底是什么呢？

:::



是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。

“集合讲的是数据，流讲的是计算！”

特点：

- Stream 自己不会存储元素

- Stream 不会改变源对象，相反，他们会返回一个持有结果的新Stream。
- Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。

![JUC-00000027](05.JUC学习笔记.assets/JUC-00000027.png)

::: note 代码举例

:::

User实体类

```java
public class User {
    private int id;
    private String userName;
    private int age;
    //get、set、有参/无参构造器、toString
}
```

Stream算法题

```java
package com.oddfar.stream;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 题目：请按照给出数据，找出同时满足以下条件的用户
 * 也即以下条件：
 * 1、全部满足偶数ID
 * 2、年龄大于24
 * 3、用户名转为大写
 * 4、用户名字母倒排序
 * 5、只输出一个用户名字 limit
 */
public class StreamDemo {
    public static void main(String[] args) {
        User u1 = new User(11, "a", 23);
        User u2 = new User(12, "b", 24);
        User u3 = new User(13, "c", 22);
        User u4 = new User(14, "d", 28);
        User u5 = new User(16, "e", 26);
        List<User> list = Arrays.asList(u1, u2, u3, u4, u5);

        /**
         * 1. 首先我们需要将 list 转化为stream流
         * 2. 然后将用户过滤出来，这里用到一个函数式接口 Predicate<? super T>，我们可以使用lambda表达式简化
         * 3. 这里面传递的参数，就是Stream流的泛型类型，也就是User，所以，这里可以直接返回用户id为偶数的用户信息;
         * 4. 通过forEach进行遍历，直接简化输出 System.out::println
         */
        list.stream()
                .filter(u -> {
                    return u.getId() % 2 == 0;
                })
                .filter(u -> {
                    return u.getAge() > 24;
                })
                .map(u -> {
                    return u.getUserName().toUpperCase();
                })
                //.sorted() //默认正排序 自己用 compareTo 比较
                .sorted((o1, o2) -> {
                    return o2.compareTo(o1);
                })
                .limit(1)
                .forEach(System.out::println);


        // map解释：
        List<Integer> list2 = Arrays.asList(1, 2, 3);
        list2 = list2.stream().map(x -> {
            return x * 2;
        }).collect(Collectors.toList());

        for (Integer element : list2) {
            System.out.println(element);
        }
        
    }

}
```

## 14、分支合并

::: tip 什么是ForkJoin

:::

从JDK1.7开始，Java提供 Fork/Join 框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。

这种思想和MapReduce很像（input --> split --> map --> reduce --> output）

主要有两步：

- 第一、任务切分
- 第二、结果合并

![JUC-00000028](05.JUC学习笔记.assets/JUC-00000028.png)

它的模型大致是这样的：线程池中的每个线程都有自己的工作队列

（PS：这一点和ThreadPoolExecutor 不同，ThreadPoolExecutor是所有线程公用一个工作队列，所有线程都从这个工作队列中取任务）

当 自己队列中的任务都完成以后，会从其它线程的工作队列中偷一个任务执行，这样可以充分利用资源。

::: tip 工作窃取

:::

另外，forkjoin有一个工作窃取的概念。简单理解，就是一个工作线程下会维护一个包含多个子任务的双端队列。而对于每个工作线程来说，会从头部到尾部依次执行任务。这时，总会有一些线程执行的速度较快，很快就把所有任务消耗完了。那这个时候怎么办呢，总不能空等着吧，多浪费资源啊。

工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：

![JUC-00000029](05.JUC学习笔记.assets/JUC-00000029.png)

那么为什么需要使用工作窃取算法呢？

假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。

工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。

于是，先做完任务的工作线程会从其他未完成任务的线程尾部依次获取任务去执行。这样就可以充分利用CPU的资源。这个非常好理解，就比如有个妹子程序员做任务比较慢，那么其他猿就可以帮她分担一 些任务，这简直是双赢的局面啊，妹子开心了，你也开心了。

::: tip 核心类

:::

**1、ForkJoinPool**

WorkQueue是一个ForkJoinPool中的内部类，它是线程池中线程的工作队列的一个封装，支持任务窃取。

什么叫线程的任务窃取呢？就是说你和你的一个伙伴一起吃水果，你的那份吃完了，他那份没吃完，那你就偷偷的拿了他的一些水果吃了。存在执行2个任务的子线程，这里要讲成存在A，B两个了。

WorkQueue在执行任务，A的任务执行完了，B的任务没执行完，那么A的WorkQueue就从B的 WorkQueue的ForkJoinTask数组中拿走了一部分尾部的任务来执行，可以合理的提高运行和计算效率。

每个线程都有一个WorkQueue，而WorkQueue中有执行任务的线程（ForkJoinWorkerThread owner），还有这个线程需要处理的任务（ForkJoinTask<?>[] array）。那么这个新提交的任务就是加到array中。

**2、ForkJoinTask**

ForkJoinTask代表运行在ForkJoinPool中的任务。

主要方法：

- fork() 在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务
- join() 当任务完成的时候返回计算结果。
- invoke() 开始执行任务，如果必要，等待计算完成。

子类： **Recursive ：递归**

- RecursiveAction 一个递归无结果的ForkJoinTask（没有返回值）
- RecursiveTask 一个递归有结果的ForkJoinTask（有返回值）



::: note 代码测试

:::

核心代码：

```java
package com.oddfar.forkJoin;

import java.util.concurrent.RecursiveTask;

/**
 * @author zhiyuan
 */
public class ForkJoinWork extends RecursiveTask<Long> {

    private Long start;//起始值
    private Long end;//结束值
    public static final Long critical = 10000L;//临界值

    public ForkJoinWork(Long start, Long end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        //判断是否是拆分完毕
        Long lenth = end - start;
        if (lenth <= critical) {
            //如果拆分完毕就相加
            Long sum = 0L;
            for (Long i = start; i <= end; i++) {
                sum += i;
            }
            return sum;
        } else {
            //没有拆分完毕就开始拆分
            Long middle = (end + start) / 2;//计算的两个值的中间值
            ForkJoinWork right = new ForkJoinWork(start, middle);
            right.fork();//拆分，并压入线程队列
            ForkJoinWork left = new ForkJoinWork(middle + 1, end);
            left.fork();//拆分，并压入线程队列

            //合并
            return right.join() + left.join();
        }
    }
}
```



三种测试：

```java
package com.oddfar.forkJoin;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.stream.LongStream;

/**
 * @author zhiyuan
 */
public class ForkJoinWorkDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        test1();//  15016
        test2();//  14694
        test3();//  216

    }

    // forkjoin这个框架针对的是大任务执行，效率才会明显的看出来有提升，于是我把总数调大到20亿。
    public static void test1() throws ExecutionException, InterruptedException {

        //ForkJoin实现
        long l = System.currentTimeMillis();

        ForkJoinPool forkJoinPool = new ForkJoinPool();//实现ForkJoin 就必须有ForkJoinPool的支持
        ForkJoinTask<Long> task = new ForkJoinWork(0L, 2000000000L);//参数为起始值与结束值
        ForkJoinTask<Long> result = forkJoinPool.submit(task);
        Long aLong = result.get();

        long l1 = System.currentTimeMillis();
        System.out.println("invoke = " + aLong + " time: " + (l1 - l));

    }


    public static void test2() {
        //普通线程实现
        Long x = 0L;
        Long y = 20_0000_0000L;
        long start_time = System.currentTimeMillis();
        for (Long i = 0L; i <= y; i++) {
            x += i;
        }
        long end_time = System.currentTimeMillis();
        System.out.println("invoke = " + x + " time: " + (end_time - start_time));

    }

    public static void test3() {
        //Java 8 并行流的实现
        long l = System.currentTimeMillis();

        long reduce = LongStream.rangeClosed(0, 2000000000L).parallel().reduce(0, Long::sum);

        long l1 = System.currentTimeMillis();
        System.out.println("invoke = " + reduce + " time: " + (l1 - l));
    }
}
```



打个比方，假设一个酒店有400个房间，一共有4名清洁工，每个工人每天可以打扫100个房间，这样，4 个工人满负荷工作时，400个房间全部打扫完正好需要1天。

Fork/Join的工作模式就像这样：首先，工人甲被分配了400个房间的任务，他一看任务太多了自己一个 人不行，所以先把400个房间拆成两个200，然后叫来乙，把其中一个200分给乙。紧接着，甲和乙再发现200也是个大任务，于是甲继续把200分成两个100，并把其中一个100分给丙， 类似的，乙会把其中一个100分给丁，这样，最终4个人每人分到100个房间，并发执行正好是1天。

